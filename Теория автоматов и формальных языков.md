# Теория автоматов и формальных языков

## 1. Формальные языки и грамматики. Классификация формальных языков и грамматик по Хомскому. Примеры.

### Понятие формального языка и грамматики

**Формальный язык** представляет собой множество строк (цепочек, слов) над некоторым алфавитом. Алфавит — конечное непустое множество символов.

Например:
- Алфавит Σ = {a, b}
- Язык L = {ε, a, ab, abb, abbb, ...} (все строки, начинающиеся с a, за которым следует произвольное количество символов b)

**Формальная грамматика** — система правил, описывающая способ генерации строк формального языка. Грамматика задаёт структуру языка и определяет, какие строки принадлежат языку, а какие — нет.

Формально грамматика G задаётся четвёркой G = (N, Σ, P, S), где:
- N — конечное множество нетерминальных символов (переменных)
- Σ — конечное множество терминальных символов (алфавит языка)
- P — конечное множество правил вывода вида α → β
- S — начальный символ грамматики (S ∈ N)

### Классификация по Хомскому

Ноам Хомский предложил иерархию формальных грамматик и языков, разделяющую их на четыре типа по возрастанию выразительной мощности:

#### Тип 0: Неограниченные грамматики
- **Правила вида:** α → β, где α ∈ (N ∪ Σ)⁺ и содержит хотя бы один нетерминал, β ∈ (N ∪ Σ)⁎
- **Соответствующие языки:** Рекурсивно перечислимые языки
- **Распознающий автомат:** Машина Тьюринга
- **Пример грамматики:** G = ({S}, {a, b}, {S → aSb, S → ab, S → SS}, S)
- **Пример языка:** Язык, где число a равно числу b, и a предшествуют соответствующим b

#### Тип 1: Контекстно-зависимые грамматики
- **Правила вида:** αAβ → αγβ, где A ∈ N, α, β ∈ (N ∪ Σ)⁎, γ ∈ (N ∪ Σ)⁺
- **Соответствующие языки:** Контекстно-зависимые языки
- **Распознающий автомат:** Линейно-ограниченный автомат
- **Пример грамматики:** G = ({S, A, B}, {a, b, c}, {S → ABC, AB → BAB, A → a, B → b, C → c}, S)
- **Пример языка:** L = {aⁿbⁿcⁿ | n ≥ 1}

#### Тип 2: Контекстно-свободные грамматики (КС-грамматики)
- **Правила вида:** A → α, где A ∈ N, α ∈ (N ∪ Σ)⁎
- **Соответствующие языки:** Контекстно-свободные языки
- **Распознающий автомат:** Автомат с магазинной памятью
- **Пример грамматики:** G = ({S}, {a, b}, {S → aSb, S → ab}, S)
- **Пример языка:** L = {aⁿbⁿ | n ≥ 1} (язык правильных скобочных структур одного вида)

#### Тип 3: Регулярные грамматики
- **Правила вида:**
  - Праволинейные: A → aB или A → a, где A, B ∈ N, a ∈ Σ
  - Леволинейные: A → Ba или A → a, где A, B ∈ N, a ∈ Σ
- **Соответствующие языки:** Регулярные языки
- **Распознающий автомат:** Конечный автомат
- **Пример грамматики:** G = ({S, A}, {a, b}, {S → aA, A → aA, A → b}, S)
- **Пример языка:** L = {aⁿb | n ≥ 1} (все строки, состоящие из одного или более символов a, после которых следует один символ b)

### Включение языков и грамматик

Между типами языков/грамматик существует строгое включение:
- Регулярные языки ⊂ Контекстно-свободные языки ⊂ Контекстно-зависимые языки ⊂ Рекурсивно перечислимые языки

Это означает, что каждый регулярный язык является контекстно-свободным, но не каждый контекстно-свободный язык является регулярным, и так далее.

## 2. Понятие конечного автомата. Примеры. Существование детерминированного конечного автомата, эквивалентного заданному недетерминированному конечному автомату.

### Понятие конечного автомата

**Конечный автомат (КА)** — математическая модель, описывающая устройство с конечным числом состояний и переходов между ними. Автомат получает на вход строку символов и, выполняя переходы из одного состояния в другое в зависимости от текущего входного символа, принимает или отвергает эту строку.

Формально детерминированный конечный автомат (ДКА) задаётся пятёркой M = (Q, Σ, δ, q₀, F), где:
- Q — конечное множество состояний
- Σ — конечный входной алфавит
- δ: Q × Σ → Q — функция переходов
- q₀ ∈ Q — начальное состояние
- F ⊆ Q — множество допускающих (финальных) состояний

### Примеры конечных автоматов

#### Пример 1: Автомат, принимающий строки, оканчивающиеся на 'ab'

Для алфавита Σ = {a, b} определим ДКА M = (Q, Σ, δ, q₀, F), где:
- Q = {q₀, q₁, q₂}
- q₀ — начальное состояние
- F = {q₂} — множество допускающих состояний
- Функция переходов δ:
  - δ(q₀, a) = q₁, δ(q₀, b) = q₀
  - δ(q₁, a) = q₁, δ(q₁, b) = q₂
  - δ(q₂, a) = q₁, δ(q₂, b) = q₀

Этот автомат принимает строки, такие как "ab", "aab", "bab", "ababab" и отвергает "a", "b", "ba", "aba".

#### Пример 2: Автомат, принимающий строки с чётным числом символов 'a'

Для алфавита Σ = {a, b} определим ДКА M = (Q, Σ, δ, q₀, F), где:
- Q = {q₀, q₁}
- q₀ — начальное состояние
- F = {q₀} — множество допускающих состояний
- Функция переходов δ:
  - δ(q₀, a) = q₁, δ(q₀, b) = q₀
  - δ(q₁, a) = q₀, δ(q₁, b) = q₁

Этот автомат принимает строки, такие как "ε" (пустая строка), "aa", "aabb", "bbaa" и отвергает "a", "aaa", "bab".

### Недетерминированные конечные автоматы

**Недетерминированный конечный автомат (НКА)** отличается от ДКА тем, что из одного состояния по одному и тому же символу может быть несколько переходов, а также могут существовать ε-переходы (переходы без считывания символа).

Формально НКА задаётся пятёркой M = (Q, Σ, δ, q₀, F), где:
- Q — конечное множество состояний
- Σ — конечный входной алфавит
- δ: Q × (Σ ∪ {ε}) → 2^Q — функция переходов (2^Q — множество всех подмножеств Q)
- q₀ ∈ Q — начальное состояние
- F ⊆ Q — множество допускающих состояний

### Эквивалентность НКА и ДКА

**Теорема:** Для любого НКА существует эквивалентный ему ДКА, т.е. такой, который распознаёт тот же язык.

#### Алгоритм преобразования НКА в ДКА (алгоритм детерминизации):

1. Каждое состояние нового ДКА соответствует некоторому подмножеству состояний исходного НКА.
2. Начальное состояние ДКА — это ε-замыкание начального состояния НКА.
3. Допускающими состояниями ДКА являются те, которые содержат хотя бы одно допускающее состояние исходного НКА.
4. Для каждого состояния ДКА и каждого символа алфавита определяем переход как объединение множеств состояний, достижимых из состояний соответствующего подмножества НКА по данному символу, с учётом ε-переходов.
5. Включаем в множество состояний ДКА только те, которые достижимы из начального состояния.

#### Пример преобразования:

Рассмотрим НКА N = (Q, Σ, δ, q₀, F), где:
- Q = {q₀, q₁, q₂}
- Σ = {a, b}
- F = {q₂}
- Функция переходов δ:
  - δ(q₀, a) = {q₀, q₁}
  - δ(q₀, b) = {q₀}
  - δ(q₁, a) = ∅ (пустое множество)
  - δ(q₁, b) = {q₂}
  - δ(q₂, a) = ∅
  - δ(q₂, b) = ∅

Эквивалентный ДКА D = (Q', Σ, δ', q₀', F'), где:
- Q' = {{q₀}, {q₀, q₁}, {q₀, q₂}, {q₀, q₁, q₂}}
- q₀' = {q₀}
- F' = {{q₀, q₂}, {q₀, q₁, q₂}}
- Функция переходов δ':
  - δ'({q₀}, a) = {q₀, q₁}
  - δ'({q₀}, b) = {q₀}
  - δ'({q₀, q₁}, a) = {q₀, q₁}
  - δ'({q₀, q₁}, b) = {q₀, q₂}
  - δ'({q₀, q₂}, a) = {q₀, q₁}
  - δ'({q₀, q₂}, b) = {q₀}
  - δ'({q₀, q₁, q₂}, a) = {q₀, q₁}
  - δ'({q₀, q₁, q₂}, b) = {q₀, q₂}

Этот ДКА распознаёт тот же язык, что и исходный НКА.

## 3. Понятие конечно-автоматного языка. Примеры. Замкнутость конечно-автоматных языков относительно операций над языками.

### Понятие конечно-автоматного языка

**Конечно-автоматный язык** (регулярный язык) — это формальный язык, который может быть распознан конечным автоматом. Другими словами, существует конечный автомат, который принимает все строки, принадлежащие языку, и отвергает все остальные.

Формально, язык L над алфавитом Σ является регулярным, если существует конечный автомат M = (Q, Σ, δ, q₀, F) такой, что L = L(M) = {w ∈ Σ⁎ | δ⁎(q₀, w) ∈ F}, где δ⁎ — расширенная функция переходов.

### Примеры регулярных языков

1. **Конечные языки**:
   - L = {a, ab, abc} — конечное множество строк
   - L = ∅ — пустой язык
   - L = {ε} — язык, содержащий только пустую строку

2. **Бесконечные регулярные языки**:
   - L = {a, aa, aaa, ...} = a⁺ — язык, состоящий из всех непустых строк, содержащих только символ 'a'
   - L = {ε, a, aa, aaa, ...} = a⁎ — язык, состоящий из всех строк, содержащих только символ 'a', включая пустую строку
   - L = {ab, aabb, aaabbb, ...} = {aⁿbⁿ | n ≥ 1} — это **не** регулярный язык (требует неограниченной памяти для подсчёта символов)

3. **Практические примеры**:
   - Язык идентификаторов в языках программирования
   - Язык целых и вещественных чисел
   - Язык комментариев в программах

### Замкнутость относительно операций над языками

Регулярные языки обладают важным свойством замкнутости относительно множества операций. Это означает, что результат применения этих операций к регулярным языкам также является регулярным языком.

#### Операции замкнутости:

1. **Объединение**: Если L₁ и L₂ — регулярные языки, то L₁ ∪ L₂ также регулярный.
   - Пример: Если L₁ = {a, aa} и L₂ = {b, bb}, то L₁ ∪ L₂ = {a, aa, b, bb}

2. **Конкатенация**: Если L₁ и L₂ — регулярные языки, то L₁L₂ также регулярный.
   - Пример: Если L₁ = {a, aa} и L₂ = {b, bb}, то L₁L₂ = {ab, abb, aab, aabb}

3. **Итерация (замыкание Клини)**: Если L — регулярный язык, то L⁎ также регулярный.
   - Пример: Если L = {a, b}, то L⁎ — множество всех строк над алфавитом {a, b}, включая пустую строку

4. **Пересечение**: Если L₁ и L₂ — регулярные языки, то L₁ ∩ L₂ также регулярный.
   - Пример: Если L₁ = {строки, содержащие символ 'a'} и L₂ = {строки, содержащие символ 'b'}, то L₁ ∩ L₂ = {строки, содержащие и 'a', и 'b'}

5. **Дополнение**: Если L — регулярный язык над алфавитом Σ, то Σ⁎ \ L также регулярный.
   - Пример: Если L = {строки, содержащие 'ab'}, то дополнение — это все строки, не содержащие подстроки 'ab'

6. **Разность**: Если L₁ и L₂ — регулярные языки, то L₁ \ L₂ также регулярный.
   - Пример: Если L₁ = {a, aa, aaa, ...} и L₂ = {aa, aaaa, ...}, то L₁ \ L₂ = {a, aaa, aaaaa, ...}

7. **Обращение (реверс)**: Если L — регулярный язык, то L^R (язык, состоящий из обращённых строк L) также регулярный.
   - Пример: Если L = {ab, abb}, то L^R = {ba, bba}

8. **Гомоморфизм**: Если L — регулярный язык, и h — гомоморфизм, то h(L) также регулярный.

9. **Обратный гомоморфизм**: Если L — регулярный язык, и h — гомоморфизм, то h⁻¹(L) также регулярный.

### Доказательство замкнутости

Для доказательства замкнутости можно использовать конструкции, показывающие, как построить конечный автомат для результирующего языка, используя автоматы для исходных языков.

Например, для объединения языков L₁ и L₂, распознаваемых автоматами M₁ и M₂ соответственно, можно построить автомат M, который имеет ε-переходы из нового начального состояния в начальные состояния автоматов M₁ и M₂. Таким образом, M будет принимать строку, если она принимается хотя бы одним из исходных автоматов.

## 4. Контекстно-свободные грамматики и языки. Примеры. Преобразования контекстно-свободных грамматик.

### Контекстно-свободные грамматики и языки

**Контекстно-свободная грамматика (КС-грамматика)** — это формальная грамматика, в которой левая часть каждого правила вывода содержит только один нетерминальный символ.

Формально КС-грамматика G = (N, Σ, P, S), где:
- N — конечное множество нетерминальных символов
- Σ — конечное множество терминальных символов
- P — конечное множество правил вида A → α, где A ∈ N и α ∈ (N ∪ Σ)⁎
- S — начальный символ грамматики (S ∈ N)

**Контекстно-свободный язык (КС-язык)** — язык, порождаемый некоторой контекстно-свободной грамматикой. Формально, L(G) = {w ∈ Σ⁎ | S ⇒⁎ w}, где ⇒⁎ означает вывод за конечное число шагов.

### Примеры контекстно-свободных языков

1. **Язык правильных скобочных выражений**:
   - Грамматика G = ({S}, {(, )}, {S → (S), S → SS, S → ε}, S)
   - Порождаемый язык: L(G) = {ε, (), ()(), (()), (())(), ...}

2. **Язык палиндромов**:
   - Грамматика G = ({S}, {a, b}, {S → aSa, S → bSb, S → a, S → b, S → ε}, S)
   - Порождаемый язык: L(G) = {ε, a, b, aa, bb, aba, bab, ...}

3. **Язык aⁿbⁿ**:
   - Грамматика G = ({S}, {a, b}, {S → aSb, S → ε}, S)
   - Порождаемый язык: L(G) = {ε, ab, aabb, aaabbb, ...}

4. **Язык арифметических выражений**:
   - Грамматика G = ({E, T, F}, {+, *, (, ), a}, {E → E+T, E → T, T → T*F, T → F, F → (E), F → a}, E)
   - Порождаемый язык: арифметические выражения с операциями +, * и скобками

### Преобразования контекстно-свободных грамматик

Существует несколько типов преобразований, которые можно применить к КС-грамматикам, сохраняя порождаемый язык:

#### 1. Устранение бесполезных символов

Бесполезные символы — это символы, которые не могут участвовать в выводе терминальных строк. Устранение бесполезных символов происходит в два этапа:
- Устранение непорождающих символов (которые не могут породить терминальную строку)
- Устранение недостижимых символов (которые не могут быть достигнуты из начального символа)

#### 2. Устранение ε-правил

ε-правила — это правила вида A → ε. Их можно устранить, заменив каждое вхождение нетерминала A в правых частях других правил на ε или оставив как есть, и рассмотрев все возможные комбинации.

#### 3. Устранение цепных правил

Цепные правила — это правила вида A → B, где B — нетерминал. Их можно устранить, заменив каждое такое правило на набор правил A → α для каждого правила B → α.

#### 4. Приведение к нормальной форме Хомского

Грамматика находится в нормальной форме Хомского (НФХ), если все её правила имеют вид:
- A → BC, где B, C ∈ N
- A → a, где a ∈ Σ
- Возможно правило S → ε, если S — начальный символ и он не встречается в правых частях других правил

Преобразование к НФХ:
1. Устранение ε-правил
2. Устранение цепных правил
3. Замена терминальных строк длиной более 1 на новые нетерминалы
4. Замена правил с более чем двумя нетерминалами в правой части

#### 5. Приведение к нормальной форме Грейбах

Грамматика находится в нормальной форме Грейбах, если все её правила имеют вид:
- A → aα, где a ∈ Σ и α ∈ N⁎
- Возможно правило S → ε, если S — начальный символ

Преобразование к нормальной форме Грейбах происходит путём систематического устранения левой рекурсии и перестановки нетерминалов в правых частях правил.

### Пример преобразования

Рассмотрим грамматику G = ({S, A, B}, {a, b}, P, S), где P:
```
S → AB | ε
A → aA | ε
B → bB | ε
```

1. Устранение ε-правил:
```
S → AB | A | B | ε
A → aA | a
B → bB | b
```

2. Устранение цепных правил (S → A, S → B):
```
S → AB | aA | a | bB | b | ε
A → aA | a
B → bB | b
```

3. Приведение к нормальной форме Хомского:
```
S → AB | AC | a | BD | b | ε
A → AC | a
B → BD | b
C → a
D → b
```

## 5. Автомат с магазинной памятью и его инструкции. Связь между автоматами с магазинной памятью и контекстно-свободными грамматиками. Примеры.

### Автомат с магазинной памятью

**Автомат с магазинной памятью (АМП)** или **стековый автомат** — это конечный автомат, расширенный магазинной (стековой) памятью. В отличие от конечного автомата, АМП может использовать неограниченную память в виде стека, что позволяет ему распознавать контекстно-свободные языки.

Формально АМП задаётся семёркой M = (Q, Σ, Γ, δ, q₀, Z₀, F), где:
- Q — конечное множество состояний
- Σ — конечный входной алфавит
- Γ — конечный алфавит магазинных символов
- δ: Q × (Σ ∪ {ε}) × Γ → ℘(Q × Γ⁎) — функция переходов
- q₀ ∈ Q — начальное состояние
- Z₀ ∈ Γ — начальный символ магазина
- F ⊆ Q — множество допускающих состояний

### Инструкции автомата с магазинной памятью

Инструкция АМП определяет, как изменяется состояние автомата и содержимое магазина при чтении символа из входной строки. Формально инструкция имеет вид:
δ(q, a, Z) = {(p₁, γ₁), (p₂, γ₂), ..., (pₖ, γₖ)}

Это означает, что, находясь в состоянии q, читая символ a (или не читая символ, если a = ε) и имея символ Z на вершине магазина, автомат может:
1. Перейти в состояние pᵢ
2. Заменить Z на вершине магазина строкой γᵢ (если γᵢ пусто, то Z удаляется; если γᵢ содержит несколько символов, то первый символ становится новой вершиной магазина)

### Работа автомата с магазинной памятью

1. Начальная конфигурация: автомат находится в состоянии q₀, магазин содержит только Z₀, указатель ленты установлен на первый символ входной строки.
2. На каждом шаге автомат выбирает одну из возможных инструкций, основываясь на текущем состоянии, символе, который он видит на ленте (или ε), и символе на вершине магазина.
3. Автомат меняет состояние, возможно модифицирует магазин и возможно перемещает указатель ленты на один символ вправо.
4. Строка принимается, если автомат достигает конечной конфигурации, в которой:
   - Вся входная строка прочитана
   - Автомат находится в допускающем состоянии (принятие по конечному состоянию)
   - Или магазин пуст (принятие по пустому магазину)

### Связь с контекстно-свободными грамматиками

Существует фундаментальная связь между АМП и КС-грамматиками:

**Теорема:** Класс языков, распознаваемых автоматами с магазинной памятью, точно совпадает с классом контекстно-свободных языков.

#### От КС-грамматики к АМП:

Для любой КС-грамматики G можно построить АМП M, который распознаёт язык L(G). Основная идея:
1. АМП хранит в магазине нетерминалы, которые ещё предстоит раскрыть.
2. Когда на вершине магазина находится нетерминал A, АМП недетерминированно выбирает одно из правил A → α и заменяет A в магазине на α (в обратном порядке).
3. Когда на вершине магазина находится терминал a, АМП сравнивает его с текущим входным символом и, если они совпадают, удаляет a из магазина и продвигается к следующему входному символу.

Формально для грамматики G = (N, Σ, P, S) строится АМП M = ({q}, Σ, N ∪ Σ, δ, q, S, ∅), где δ:
- δ(q, ε, A) = {(q, α)} для каждого правила A → α
- δ(q, a, a) = {(q, ε)} для каждого a ∈ Σ

#### От АМП к КС-грамматике:

Для любого АМП M можно построить КС-грамматику G, порождающую язык L(M). Процесс более сложный и включает создание нетерминалов вида [pAq], обозначающих, что автомат, начиная в состоянии p с символом A на вершине магазина, может закончить в состоянии q с пустым магазином.

### Примеры

#### Пример 1: АМП для языка {aⁿbⁿ | n ≥ 1}

Создадим АМП M = ({q₀, q₁, q₂}, {a, b}, {Z₀, A}, δ, q₀, Z₀, {q₂}), где:
- δ(q₀, a, Z₀) = {(q₀, AZ₀)} — начинаем читать 'a' и записываем A в магазин
- δ(q₀, a, A) = {(q₀, AA)} — читаем 'a' и добавляем ещё A в магазин
- δ(q₀, b, A) = {(q₁, ε)} — начинаем читать 'b' и удаляем A из магазина
- δ(q₁, b, A) = {(q₁, ε)} — продолжаем читать 'b' и удалять A
- δ(q₁, ε, Z₀) = {(q₂, Z₀)} — если все A удалены, переходим в допускающее состояние

Этот автомат работает следующим образом:
1. Для каждого 'a' во входной строке добавляет символ A в магазин
2. Затем, для каждого 'b' удаляет символ A из магазина
3. Если количество 'a' равно количеству 'b', то магазин будет содержать только Z₀, и автомат перейдёт в допускающее состояние

#### Пример 2: КС-грамматика для языка {wwᴿ | w ∈ {a, b}⁺}

Рассмотрим язык палиндромов чётной длины. КС-грамматика для этого языка:
G = ({S}, {a, b}, {S → aSa, S → bSb, S → ε}, S)

Соответствующий АМП:
M = ({q₀, q₁, q₂}, {a, b}, {Z₀, a, b}, δ, q₀, Z₀, {q₂}), где:
- δ(q₀, a, Z₀) = {(q₀, aZ₀)} — читаем 'a' и записываем его в магазин
- δ(q₀, b, Z₀) = {(q₀, bZ₀)} — читаем 'b' и записываем его в магазин
- δ(q₀, a, a) = {(q₀, aa)} — продолжаем читать и записывать
- δ(q₀, a, b) = {(q₀, ab)} — продолжаем читать и записывать
- δ(q₀, b, a) = {(q₀, ba)} — продолжаем читать и записывать
- δ(q₀, b, b) = {(q₀, bb)} — продолжаем читать и записывать
- δ(q₀, ε, Z₀) = {(q₁, Z₀)} — переход к чтению второй половины
- δ(q₁, a, a) = {(q₁, ε)} — читаем 'a' и удаляем 'a' из магазина
- δ(q₁, b, b) = {(q₁, ε)} — читаем 'b' и удаляем 'b' из магазина
- δ(q₁, ε, Z₀) = {(q₂, Z₀)} — если магазин пустой (кроме Z₀), переходим в допускающее состояние

Этот автомат сначала записывает первую половину входной строки в магазин, а затем сравнивает вторую половину с содержимым магазина (в обратном порядке).

## 6. Машина Тьюринга. Формат команд и программа машины Тьюринга. Примеры. Рекурсивные и рекурсивно перечислимые языки.

### Машина Тьюринга

**Машина Тьюринга (МТ)** — это абстрактная вычислительная модель, которая состоит из управляющего устройства с конечным числом состояний и бесконечной ленты, разделенной на ячейки. Машина Тьюринга является наиболее мощной моделью вычислений и может моделировать любой алгоритм.

Формально машина Тьюринга задаётся семёркой M = (Q, Σ, Γ, δ, q₀, □, F), где:
- Q — конечное множество состояний
- Σ — конечный входной алфавит
- Γ — конечный ленточный алфавит (Σ ⊂ Γ)
- δ: Q × Γ → Q × Γ × {L, R, N} — функция переходов
- q₀ ∈ Q — начальное состояние
- □ ∈ Γ \ Σ — пустой символ
- F ⊆ Q — множество допускающих состояний

### Формат команд и программа машины Тьюринга

Команда машины Тьюринга имеет вид:
δ(q, a) = (p, b, D)

Это означает, что, находясь в состоянии q и читая символ a:
1. Машина переходит в состояние p
2. Заменяет символ a на ленте символом b
3. Перемещает головку в направлении D (L — влево, R — вправо, N — остаётся на месте)

**Программа** машины Тьюринга — это полный набор команд для всех пар (состояние, символ), которые могут встретиться в процессе вычисления.

Обычно программа МТ представляется в виде таблицы переходов или списка команд.

### Работа машины Тьюринга

1. Начальная конфигурация: машина находится в состоянии q₀, на ленте записана входная строка, головка установлена на первый символ строки.
2. Машина выполняет команды в соответствии с функцией переходов:
   - Считывает символ под головкой
   - Определяет новое состояние, новый символ для записи и направление движения
   - Записывает новый символ и перемещает головку
3. Машина останавливается, когда нет подходящей команды для текущей пары (состояние, символ).
4. Строка принимается, если машина останавливается в допускающем состоянии.

### Примеры машин Тьюринга

#### Пример 1: Машина Тьюринга для языка {aⁿbⁿcⁿ | n ≥ 1}

Опишем программу МТ, которая проверяет, содержит ли входная строка равное количество символов a, b и c, идущих в указанном порядке.

Идея алгоритма:
1. Заменить первый символ a на X, первый символ b на Y и первый символ c на Z
2. Вернуться в начало строки
3. Повторять шаги 1-2, пока не закончатся символы a, b, c
4. Проверить, что все символы a, b, c заменены на X, Y, Z, и их количество одинаково

Таблица переходов:
```
(q₀, a) → (q₁, X, R)  // Заменяем первый a на X и переходим к поиску b
(q₀, Y) → (q₄, Y, R)  // Если дошли до Y, значит, все a заменены, переходим к проверке
(q₀, □) → (q₅, □, N)  // Если лента пуста, останавливаемся
(q₁, a) → (q₁, a, R)  // Пропускаем оставшиеся a
(q₁, b) → (q₂, Y, R)  // Заменяем первый b на Y и переходим к поиску c
(q₂, b) → (q₂, b, R)  // Пропускаем оставшиеся b
(q₂, c) → (q₃, Z, L)  // Заменяем первый c на Z и начинаем движение назад
(q₃, a) → (q₃, a, L)  // Движение назад
(q₃, b) → (q₃, b, L)  // Движение назад
(q₃, c) → (q₃, c, L)  // Движение назад
(q₃, X) → (q₃, X, L)  // Движение назад
(q₃, Y) → (q₃, Y, L)  // Движение назад
(q₃, Z) → (q₃, Z, L)  // Движение назад
(q₃, □) → (q₀, □, R)  // Вернулись к началу строки, продолжаем алгоритм
(q₄, Y) → (q₄, Y, R)  // Проверка: пропускаем все Y
(q₄, Z) → (q₄, Z, R)  // Проверка: пропускаем все Z
(q₄, □) → (q₅, □, N)  // Если после всех Y и Z лента закончилась, строка принята
```

Здесь q₅ — допускающее состояние.

#### Пример 2: Машина Тьюринга для копирования строки

Рассмотрим МТ, которая принимает строку вида w#, где w ∈ {0, 1}⁺, и превращает её в w#w.

Идея алгоритма:
1. Заменить первый символ w на его маркированную версию (0 на 0', 1 на 1')
2. Передвинуться за # и скопировать этот символ
3. Вернуться к началу строки, найти следующий немаркированный символ, и повторить шаги 1-2
4. Когда все символы маркированы, убрать маркировку

Эта задача показывает способность машины Тьюринга осуществлять сложные манипуляции с данными.

### Рекурсивные и рекурсивно перечислимые языки

Машины Тьюринга тесно связаны с понятиями рекурсивных и рекурсивно перечислимых языков:

#### Рекурсивно перечислимые языки

**Рекурсивно перечислимый язык** — это формальный язык, для которого существует МТ, принимающая все строки, принадлежащие языку, и не принимающая (или зацикливающаяся) для строк, не принадлежащих языку.

Формально, язык L ⊆ Σ⁎ является рекурсивно перечислимым, если существует МТ M такая, что L = L(M) = {w ∈ Σ⁎ | M принимает w}.

Рекурсивно перечислимые языки — это в точности языки типа 0 по иерархии Хомского (порождаемые неограниченными грамматиками).

#### Рекурсивные языки

**Рекурсивный язык** — это формальный язык, для которого существует МТ, которая останавливается на любой входной строке и принимает строку тогда и только тогда, когда она принадлежит языку.

Формально, язык L ⊆ Σ⁎ является рекурсивным, если существует МТ M такая, что:
1. L = L(M) = {w ∈ Σ⁎ | M принимает w}
2. M останавливается для любой входной строки w ∈ Σ⁎

Рекурсивные языки — это в точности разрешимые проблемы в теории вычислимости. Каждый рекурсивный язык является рекурсивно перечислимым, но не наоборот.

#### Примеры

1. **Рекурсивные языки**:
   - Все регулярные языки
   - Все контекстно-свободные языки
   - Язык {aⁿbⁿcⁿ | n ≥ 1}
   - Язык всех простых чисел в бинарной записи

2. **Рекурсивно перечислимые, но не рекурсивные языки**:
   - Язык всех МТ, которые останавливаются на пустой ленте
   - Язык всех пар (M, w), где M — кодировка МТ, и M принимает строку w (проблема остановки)

**Теорема о неразрешимости проблемы остановки**: Не существует алгоритма, который, получив на вход описание произвольной МТ M и входную строку w, определяет, остановится ли M на w.